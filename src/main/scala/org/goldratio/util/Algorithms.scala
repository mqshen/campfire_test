package org.goldratio.util

/**
 * Created by GoldRatio on 4/9/14.
 */
/**
 * Created by GoldRatio on 3/26/14.
 */
import java.nio.charset.Charset
import java.security.MessageDigest
import java.security.NoSuchAlgorithmException

import javax.crypto.Mac
import javax.crypto.spec.SecretKeySpec

/**
 * Describe class Algorithms here.
 *
 *
 * Created: Wed May  4 13:24:03 2005
 *
 * @author <a href="mailto:artur.hefczyc@tigase.org">Artur Hefczyc</a>
 * @version $Rev$
 */
object Algorithms {


  def hexDigest(id: String, secret: String, alg: String): String ={
    bytesToHex(digest(id, secret, alg))
  }

  val HASH_ALGO = "SHA-256"

  def HMAC_ALGO = "HmacSHA256"

  val NULL_CHARS_ARRAY = ( 110, 117, 108, 108 ).asInstanceOf[Array[Byte]]

  def digest(id: String, secret: String , alg: String): Array[Byte] = {
    val md = MessageDigest.getInstance(alg)

    if (id == null)
      md.update(NULL_CHARS_ARRAY)
    else
      md.update(id.getBytes())

    if (secret == null)
      md.update(NULL_CHARS_ARRAY)
    else
      md.update(secret.getBytes())

    md.digest()
  }

  def bytesToHex(buff: Array[Byte]): String = {
    val res = new StringBuilder()
    buff.foreach { b =>
      var ch = Character.forDigit((b >> 4) & 0xF, 16)
      res.append(ch)
      ch = Character.forDigit(b & 0xF, 16)
      res.append(ch)
    }
    res.toString()
  }

  def help(): String = {
    " -id id				id used to calculate digest\n" +
      " -pass pass			password phrase for digest calculation\n"  +
      " -alg alg			algorith to use for calculating digest\n"
  }

//  /**
//   * Describe <code>main</code> method here.
//   *
//   * @param args a <code>String[]</code> value
//   */
//  public static void main(final String[] args) throws Exception {
//    String id = null
//    String pass = null
//    String alg = "MD5"
//    for (int i = 0 i < args.length; i++) {
//      if (args[i].equals("-h")) {
//        System.out.println(help())
//        System.exit(0)
//      } // end of if (args[i].equals("-id"))
//      if (args[i].equals("-id")) {
//        id = args[++i]
//      } // end of if (args[i].equals("-id"))
//      if (args[i].equals("-pass")) {
//        pass = args[++i]
//      } // end of if (args[i].equals("-id"))
//      if (args[i].equals("-alg")) {
//        alg = args[++i]
//      } // end of if (args[i].equals("-id"))
//    } // end of for (int i = 0 i < args.length; i++)
//    if (id == null) {
//      id = ""
//    } // end of if (id == null)
//    System.out.println(hexDigest(id, pass, alg))
//  }


  /**
   * Calculates dialback key as decribed in <a
   * href='http://xmpp.org/extensions/xep-0185.html'>XEP-0185</a> version 1.0.
   *
   * <p>
   * Implemented algorithm (recomended in XEP-0185):
   *
   * <pre>
   * key = HMAC-SHA256
   *       (
   *         SHA256(Secret),
   *         {
   *           Receiving Server, ' ',
   *           Originating Server, ' ',
   *           Stream ID
   *         }
   *       )
   * </pre>
   *
   * </p>
   *
   * @param originatingServer
     *            the hostname of the Originating Server
   * @param receivingServer
     *            the hostname of the Receiving Server
   * @param secret
     *            a secret known by the Authoritative Server's network
   * @param streamID
     *            the Stream ID generated by the Receiving Server
   * @return string contains HEX encoded dialback key.
   */
  def generateDialbackKey(originatingServer: String, receivingServer: String, secret: String , streamID: String ): String = {
    try {
      val charSet = Charset.forName("US-ASCII")
      val sha = Mac.getInstance(HMAC_ALGO)

      val secret_key = new javax.crypto.spec.SecretKeySpec(charSet.encode(sha256(secret)).array(), HMAC_ALGO)
      sha.init(secret_key)

    sha.update(receivingServer.getBytes())
    sha.update(' '.toByte)
    sha.update(originatingServer.getBytes())
    sha.update(' '.toByte)
    sha.update(streamID.getBytes())

    return bytesToHex(sha.doFinal())

    } catch  {
      case e: Exception =>
      e.printStackTrace()
      return null
    }

  }

  /**
   * Calculates SHA-256 hash of given data.
   *
   * @param data
     *            data to hash
   * @return string contains HEX encoded SHA-256 of data.
   */
  def sha256(data: String ): String = {
    try {
      val sha = MessageDigest.getInstance(HASH_ALGO)
      bytesToHex(sha.digest(data.getBytes()))
    } catch {
      case e: Exception =>
        e.printStackTrace()
        null
    }
  }
}

